# 线程状态

- 线程可以有6种状态：
  - New (新建)
  - Runnable (可运行)
  - Blocked (阻塞)
  - Waiting (等待)
  - Timed waiting (计时等待)
  - Terminated (终止)

## 一、新建线程

- 使用 new 操作符创建一个新线程：

  ```java
  new Thread(r);
  ```

  这个线程还没有开始运行

## 二、可运行线程

- 一旦调用 start 方法，线程就处于 `可运行` 状态。一个可运行的线程可能正在运行也可能没有运行。要由操作系统为线程提供具体的运行时间
- 一旦一个线程开始运行，它不一定始终保持运行。事实上，运行中的线程有时需要暂停，让其他线程有机会运行。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完时，操作系统`剥夺`该线程的运行权，并给另一个线程机会来运行。当选择下一个线程时，操作系统会考虑线程的优先级
- 现在所有的桌面以及服务器操作系统都使用抢占式调度手机这样的小型设备可能使用协作式调用
- java.lang.Thread
  - static void yield()：使当前正在执行的线程向另一个线程交出运行权。这是一个静态方法

## 三、阻塞和等待线程

当线程处于阻塞或等待状态时，它暂时是不活动的。它不运行任何代码，而且消耗最少的资源。要由线程调度器重新激活这个线程。

- 当一个线程试图获取一个内部的对象锁，而这个锁目前被其他线程占有，该线程就会被阻塞。当所有其他线程都释放这个锁，并且线程调度器允许该线程持有这个锁时，它将变成非阻塞状态
- 当线程等待另一个线程通知出现一个条件时，这个线程会进入等待状态。调用 Object.wait 方法或Thread.join 方法，或者是等待 java.util.concurrent 库中的 Lock 或 Condition 时，就会出现这样的情况。实际上，阻塞状态与等待状态并没有什么太大的区别
- 有几个方法有超时参数，调用这些方法会让线程进入`计时等待`状态。这一状态将一直保存到超时期满或者接收到适当的通知。带有超时参数的方法有 Thread.sleep 和计时版的 Object.wait、Thread.join、Lock.tryLock 以及 Condition.await
- 当一个线程阻塞或等待时（终止时），可以调度另一个线程运行。当一个线程被重新激活（例如，因为超时期满或成功获得一个锁），调度器会检查它是否具有比当前运行线程更高的优先级

## 四、线程终止

- 线程会由于以下两个原因之一而终止：

  - run 方法正常退出，线程自然终止
  - 因为一个没有捕获的异常终止了 run 方法，使线程意外终止

  调用线程的 stop 方法杀死一个线程。该方法抛出一个 ThreadDeath 错误对象，这个会杀死线程。不过 stop 方法已经废弃，不要在你的代码中调用这个方法

- java.lang.Thread

  - void join()：等待终止指定的线程

  - void join(long millis)：等待指定的线程终止或等待经过指定的毫秒数

  - Thread.State getState()：得到这个线程的状态；取值为 NEW 、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING 或 TERMINATED

  - void stop()：停止该线程。这个方法已经废弃

  - void suspend()：暂停这个线程的执行，这个方法已经废弃

  - void resume()：恢复线程。这个方法只能在调用 suspend() 之后使用。这个方法已经废弃

    