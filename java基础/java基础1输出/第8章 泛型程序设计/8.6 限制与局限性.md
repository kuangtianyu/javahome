# 限制与局限性

### 8.6.1 不能用基本类型实例化类型参数

- 不能用基本类型代替类型参数。因此，没有Pair<double>，只有Pair<Double>。当然，其原因就在于类型擦除。擦除之后， Pair类含有 Object 类型的字段，而Object不能 double 值

### 8.6.2 运行时类型查询只适用于原始类型

- 虚拟机中的对象总有一个特定的非泛型类型。因此，所有的类型查询值产生原始类型

- 如果试图查询一个对象是否属于某个泛型类型，你会得到一个编译器错误（使用instanceof时），或者得到一个警告（使用强制类型转换时）

- getClass 方法总是返回原始类型。例如：

  ```java
  pair<String> stringPair = ...;
  Pair<Employee> employeePair = ...;
  if (stringPair.getClass() == employeePair.getClass()) //they are equal
  ```

  其比较的结果是 true， 这是因为两次 getClass 调用都返回 Pair.class 

### 8.6.3 不能创建参数化类型的数组

- 不能实例化参数化类型的数组，例如：

  ```java
  var table = new Pair<String>[10]; //ERROR
  ```

  擦除之后，table的类型是 Pair[] 。可以把它转换为 Object[]:

  ```java
  Object[] objarray = table;
  ```

  数组会记住它的元素类型，如果试图存储其他类型的元素，就会抛出一个ArrayStoreException异常：

  ```java
  objarray[0] = "Hello"; // ERROR--component type is Pair
  ```

  不过对于泛型类型，擦除会使这种机制无效。以下赋值：

  ```java
  objarray[0] = new Pair<Employee>();
  ```

  尽管能够通过数组存储的检查，但仍会导致一个类型错误，出于这个原因，不允许创建参数化类型的数组

### 8.6.4 Varargs 警告

- 向参数个数可变的方法传递一个泛型类型的实例：

  ```java
  public static<T> void addAll(Collection<T>) coll, T... ts){
  	for (T t : ts) coll.add(t);
  }
  ```

  实际上参数 ts 是一个数组，包含提供的所有实参。考虑以下调用：

  ```java
  Collection<Pair<String>> table = ...;
  Pair<String> pair1 = ...;
  Pair<String> pair2 = ...;
  addAll(table, pair1, pair2);
  ```

  为了调用这个方法，Java虚拟机必须建立一个Pair<String> 数组，这违反了Java不支持泛型类型的数组。不过，对于这种情况，规则有所放松，只会得到一个警告，而不是错误。

  可以为包含addAll调用的方法增加注解 @SuppressWarnings("unchecked")。在Java7当中还可以用 @SafeVarargs直接注解addAll方法

- @SafeVarargs 只能用于声明为 static、final 或 （Java9）private的构造器和方法。所有其他方法可能被覆盖，使得这个注解没有什么意义

### 8.6.5 不能构造泛型数组

- 既不能抛出也不能捕获泛型类的异常的对象
- catch子句中不能使用类型变量
- 在异常规范中使用类型变量是允许的

