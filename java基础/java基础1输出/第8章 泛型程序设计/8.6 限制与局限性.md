# 限制与局限性

### 8.6.1 不能用基本类型实例化类型参数

- 不能用基本类型代替类型参数。因此，没有Pair<double>，只有Pair<Double>。当然，其原因就在于类型擦除。擦除之后， Pair类含有 Object 类型的字段，而Object不能 double 值

### 8.6.2 运行时类型查询只适用于原始类型

- 虚拟机中的对象总有一个特定的非泛型类型。因此，所有的类型查询值产生原始类型

- 如果试图查询一个对象是否属于某个泛型类型，你会得到一个编译器错误（使用instanceof时），或者得到一个警告（使用强制类型转换时）

- getClass 方法总是返回原始类型。例如：

  ```java
  pair<String> stringPair = ...;
  Pair<Employee> employeePair = ...;
  if (stringPair.getClass() == employeePair.getClass()) //they are equal
  ```

  其比较的结果是 true， 这是因为两次 getClass 调用都返回 Pair.class 

### 8.6.3 不能创建参数化类型的数组

- 不能实例化参数化类型的数组，例如：

  ```java
  var table = new Pair<String>[10]; //ERROR
  ```

  擦除之后，table的类型是 Pair[] 。可以把它转换为 Object[]:

  ```java
  Object[] objarray = table;
  ```

  数组会记住它的元素类型，如果试图存储其他类型的元素，就会抛出一个ArrayStoreException异常：

  ```java
  objarray[0] = "Hello"; // ERROR--component type is Pair
  ```

  不过对于泛型类型，擦除会使这种机制无效。以下赋值：

  ```java
  objarray[0] = new Pair<Employee>();
  ```

  尽管能够通过数组存储的检查，但仍会导致一个类型错误，出于这个原因，不允许创建参数化类型的数组