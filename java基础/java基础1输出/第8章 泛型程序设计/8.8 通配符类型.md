# 通配符类型

## 一、通配符概念

- 在通配符类型中，允许类型参数发生变化。例如：通配符类型：

  ```java
  Pair<? extends Employee>
  ```

  表示任何泛型Pair类型，它的类型参数是Employee的子类，如 Pair<Manager>, 但不是Pair<String>

- 如下代码：

  ```java
  public static void printBuddies(Pair<Employee> p) {
  	Employee first = p.getFirst();
  	Employee second = p.getSecond();
  	System.out.println(first.getName()+"and"+second.getName()+" are buddies.");
  }
  ```

  不能将 Pair<Manager> 传递给这个方法。可以如下解决：

  ```java
  public static void printBuddies(Pair<? extends Employee)
  ```

  类型  Pair<Manager>是 Pair<? extends Employee> 的子类型

- 如下代码：

  ```java
  ? extends Employee getFirst()
  void setFirst(? extends Employee)
  ```

  这样将不可能调用 setFirst 方法。编译器只知道需要将 Employee 的某个子类型，但不知道具体是什么类型。它拒绝传递任何特定的类型。毕竟？不能匹配。

  使用 getFirst 就不存在这个问题：将 getFirst 的返回值赋给一个 Employee 引用时完全合法的

## 二、通配符的超类型限定

- 指定一个`超类型限定`：

  ```java
  ? super Manager
  ```

  这个通配符限制为 Manager 的所有超类型，可以为方法提供参数，但不能有返回值

  ```java
  void setFirst(? super Manager)
  ? super Manager getFirst()
  ```

  编译器无法知道setFirst方法的具体类型，因此不能接受参数类型为Employee 或 Object 的方法调用。只能传递 Manager 类型的对象， 或者把某个子对象 （如 Executive）对象。另外，如果调用getFirst，不能保证返回对象的类型。只能把它赋给一个Object。

- 直观的讲，带有超类型限定的通配符允许你写入一个泛型对象，而带有子类型限定的通配符允许你读取一个泛型对象。

## 三、无限定通配符

- 无限定的通配符：Pair<?> ，类型 Pair<?> 有一下方法：

  ```java
  ? getFirst()
  void SetFirst(?)
  ```

  getFirst 的返回值只能赋给一个 Object. setFirst 方法不能被调用，甚至不能用 Object 调用。Pair<?> 和 Pair本质的不同在于：可以用任意 Object 对象调用原始 Pair 类的setFirst方法

## 四、通配符捕获

- 看代码：

  ```java
  public static void swap(Pair<?> p)
  ```

- 通配符不是类型变量，因此不能在编写代码中使用 ”？“ 作为一种类型。也就是说，下面的代码是非法的：

  ```java
  ? t = p.getFirst(); //ERROR
  p.setFirst(p.getSecond());
  p.setSecond(t);
  ```

  问题：在交换的时候必须临时保存第一个元素。

  解决方案：写一个辅助方法 swapHelper：

  ```java
  public static <T> void swapHelper(Pair<T> p) {
  	T t = p.getFirst();
  	p.setFirst(p.getSecond());
  	p.setSecond(t);
  }
  ```

  注意： swapHelper 是一个泛型方法，而 swap 不是，它有一个固定的 Pair<?> 类型的参数。

  swap 调用 swapHelper:

  ```java
  public static void swap(Pair<?> p) {
  	swapHelper(P);
  }
  ```

- 捕获通配符：在编译器必须能够保证通配符表示单个确定的类型条件下，才可以使用捕获通配符。