# 泛型代码和虚拟机

### 8.5.1 类型擦除

- 无论何时定义一个泛型类型，都会自动提供一个相应的`原始类型`。这个原始类型的名字就是去掉类型参数后的泛型类型名。类型变量会被擦除，并替换为其限定类型（或者，对于无限定的变量则替换为Object）

  ```java
  public class Pair{
  	private Object first;
  	...
  }
  ```

  因为T是一个无固定的变量，所以直接用Object替换

- 程序中可以包含不同类型的Pair，例如：Pair<String> 或 Pair<LocalDate>。擦除类型后，它们都会变成原始的Pair类型

### 8.5.2 转换泛型表达式

- 编写一个泛型方法调用时，如果擦除了返回类型，编译器会插入强制类型转换。例如：

  ```java
  Pair<Employee> buddies = ...
  Employee buddy = buddies.getFirst();
  ```

  getFirst() 擦除类型后的返回类型是 Object。编译器自动插入转换到 Employee 的强制类型转换。编译器会把这个方法调用转换为两条虚拟机指令：

  - 对原始方法 Pair.getFirst 的调用
  - 将返回的 Object 类型强制转换为 Employee 类型

### 8.5.3 转换泛型方法

- 虚拟机中没有泛型，只有普通的类和方法
- 所有的类型参数都会替换为它们的限定类型
- 会合成桥方法来保持多态
- 为保持类型安全性，必要时会插入强制类型转换

