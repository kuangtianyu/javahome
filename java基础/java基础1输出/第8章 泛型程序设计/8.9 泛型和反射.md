# 泛型和反射

## 一、泛型Class类

- Class 类是泛型的。例如：String.class 实际上是一个 Class<String> 类的对象（事实上是唯一的对象）

- 类型参数十分有用：它允许 Class<T> 方法的返回类型更加就有特定性。

- ```java
  T new Instance()
  ```

  newInstance 方法返回这个类的一个实例，有无参数构造器获得。它的返回值类型被声明为 T, 其类型与 Class<T> 描述的类相同，这样就免除了类型转换

- ```java
  T cast(Object obj)
  ```

  如果给定对象的类型实际上是 T 的一个子类型， cast方法就会返回这个给定对象（现在声明为类型T)， 否则，会抛出一个 BadCastException 异常

- ```java
  T[] getEnumConstants()
  ```

  如果这个类不是 enum 类或 T 类型枚举值的数组， getEnumConstants 方法将返回 null。

- ```java
  Constructor<T> getConstructor(Class... parameterTypes)
  Constructor<T> getDeclaredConstructor(Class... parameterTypes)
  ```

  getConstructor 与 getdeclaredConstructor方法返回一个 Constructor<T> 对象。Constructor类也已经变成泛型，从而使 newInstance 方法有一个正确的返回类型

## 二、使用 Class<T> 参数进行类型匹配

- 匹配泛型方法中 Class<T> 参数的类型变量有时会很有用：

  ```
  public static <T> Pair<T> makePair(Class<T> c) throws InstantiationException, IlegalAccessException {
  	return new Pair<>(c.newInstance(), c.newInstance());
  }
  ```

  如果调用 makePair(Employee.class) ，Employee.class 将是一个 Class<Employee> 类型的对象。makePair 方法的类型参数 T 同 Employee 匹配，编译器可以推断出这个方法将返回一个 Piar<Employee>.

## 三、虚拟机中的泛型类型信息

- Java 泛型突出特性之一是在虚拟机中擦除泛型类型

- 考虑以下方法：

  ```java
  public static Comparable min(Comparable[] a)
  ```

  擦除泛型方法后：

  ```java
  public static<T extends Comparable<? super T>> T min(T[] a)
  ```

  可以只有反射API来确定类型：

  - 这个泛型方法有一个名为 T 的类型参数
  - 这个类型参数有一个子类型限定， 其自身又是一个泛型类型
  - 这个限定类型有一个通配符参数
  - 这个通配符参数有一个超类型限定
  - 这个发型方法有一个泛型数组参数

  可以使用 java.lang.reflect 包中的接口 Type 来表述泛型类型声明：

  - Class 类，描述具体类型。
  - TypeVariable 接口， 描述类型变量 （如 T  extends Comparable<? super T>)
  - WildcardType 接口，描述通配符 （如 ？super T)
  - ParameterizedType 接口，描述泛型类或接口类型（如 Comparable<? super T>)
  - GenericArrayType 接口，描述泛型数组（如 T[]）

