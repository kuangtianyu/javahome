## 泛型数组列表

### 1.声明数组列表

- 声明和构造一个保存Employee对象的数组列表:

  ```java
  ArrayList<Employee> staff = new ArrayList<Employee>;
  ```

- 在`Java10`中，最好使用var关键字以避免重复写类名

  ```java
  var staff = new ArrayList<Employee>;
  ```

- 如果没有使用`var`关键字，可以省去右边的类型参数

  ```java
  ArrayList<> staff = new ArrayList<Employee>;
  ```

- 数组列表（`ArrayList`)的长度是可以改变的

- 向数组列表中添加元素：使用`add`方法

  ```java
  staff.add(new Employee("Harry Hacker",...));
  ```

  数组列表管理着一个内部的对象引用数组，当这个数组的空间用尽时，数组列表就会自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中

- 如果已经知道或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用`ensureCapacity`方法：

  ```java
  staff.ensureCapacity(100);
  ```

  这个方法调用将分配一个包含100个对象的内部数组，这样一来，前100次`add`调用不会带来开销很大的分配空间,垃圾回收器将回收多余的存储空间

- 使用`size`方法将返回数组列表中包含的实际元素个数：

  ```java
  staff.size();
  ```

- `java.util.ArrayList<E>`
  - `ArrayList<E>()`：构造一个空数组列表
  - `ArrayList<E>(int initialCapacity)`：用于指定容量构造一个空数组列表
  - `boolean add(E obj)`：在数组列表的末尾追加一个元素。永远返回`true`
  - `int size()`：返回当前存储在数组列表中的元素个数。（当然，这个值永远不会大于数组列表的容量）
  - `void ensureCapacity(int capacity)`：确保数组列表在不重新分配内部存储数组的情况下有足够的容量存储给定数量的元素
  - `void trimToSize()`：将数组列表的存储容量削减到当前大小

### 2.访问数组列表元素

- 改变数组类别中的某个元素：`set`方法

  ```
  staff.set(i, harry);
  ```

  它把第i个元素设置为`harry`，等价于对数组`a`的元素赋值一样（与数组一样，下标值从0开始）

  ```
  a[i] = harry;
  ```

  警告：只有当数组列表的大小大于`i`时，才能够调用`staff.set(i, harry)`;

- 得到一个数组列表中的元素：`get`方法

  ```
  Employee e = staff.get(i);
  ```

  等价于：

  ```
  Employee e = a[i];
  ```

- 使用`toArray`方法将数组元素拷贝到一个数组中：

  ```
  var a = new X[list.size()];
  list.toArray(a);
  ```

- `java.util.ArrayList<E>`
  - `E set(int index, E obj)`：将值`obj`放置在数组列表的指定索引位置，返回之前的内容
  - `E get(int index)`：得到指定索引位置存储的值
  - `void add(int index, E obj)`：后移元素从而将`obj`插入到指定索引位置
  - `E remove(int index)`：删除指定索引位置的元素，并将后面的所有元素前移。返回所删除的元素



