

## 1.定义子类

- 假如有一个`Employee`类和一个`Manage`r类，Manager类需要使用关键字extends来继承Employee类：

  ```java
  public class Manager extends Employee{
  	added methods and fields
  }
  ```

  关键字extends表明正在构造的新类派生与一个已存在的类。这个已存在的类称为`超类`、`基类`或`父类`；新类称为`子类`、`派生类`或`孩子类`。

- 子类对象可以使用父类中的字段和方法（私有字段和私有方法除外），而父类对象不能使用子类的方法
- 应该将最一般的方法放在超类中，而将更特殊的方法放在子类中

## 2.覆盖方法

- 超类中的有些方法对于子类来说并不一定 适用，这时子类需提供一个新的方法类覆盖超类中的这个方法。

- 假如你覆盖父类中的这个方法的时候，需要调用父类的这个方法，就需要使用super关键字。例如：

  ```java
  public double getSalary(){
  	double baseSalary = super.getSalary();
  	return baseSalary + bonus;
  }
  ```

## 3.子类构造器

- 子类可以调用父类的构造器：

  ```java
  public Manager(String name, double salary, int month, int day){
  	super(name, salary,year,month,day);
  }
  ```

  使用super调用构造器的语句必须是子类构造器的第一条语句

- 如果子类的构造器没有显式地调用超类的构造器，将自动地调用超类的无参数构造器。如果超类没有无参数构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，Java编译器就会报错
- Java不支持多重继承，当是支持多层继承

## 4.多态

- 一个对象变量可以指示多种实际类型的现象称为多态
- 在运行时能够自动地选择适当的方法，称为动态绑定

- 在Java中，一个父类类型的变量既可以引用一个父类类型的对象，也可以引用父类的任何一个子类的对象

  ```java
  Employee boss = new Manager(...);
  ```

  

- 注意：一个子类类型的变量不可以引用父类类型的对象

## 5.阻止继承：final类和方法

- final类：假如一个类被final关键字修饰，就表明这个类不能被继承，其中的所有方法也自动的成为final，而字段不会
- final方法：类中的某个方法被final修饰，子类就不能覆盖这个方法。

## 6.强制类型转换

- 强制类型转换：将一个类型强制转换成另一个类型的过程称为强制类型转换

- 要完成对象引用的强制类型转换，需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前，例如：

  ```java
  Manager boss = new Manager("Carl Cracker",80000,1987,12,15)
  boss.setBonus(5000);
  var staff = new Employee[3];
  staff[0] = boss;
  staff[1] = new Employee("Harry Hacker",50000,1989,10,1);
  staff[2] = new Employee("Tony Tester",40000,1990,3,15);
  Manager boss = (Manager) staff[0];//强制类型转换
  ```

- 如果将一个类的引用赋给一个超类变量（多态），编译器是允许的。但将一个超类的引用赋给一个子类变量时，就承若过多了。必须进行强制类型转换

- 在继承链上进行向下的强制类型转换，发生如下情况怎么办

  ```java
  Manager boss = (Manager) staff[1]; //ERROR
  ```

  在运行时，系统注意到你的承若不符，并产生一个ClassCastException异常。如果没有捕获这个异常，那么程序就会终止。因此，在转换之前先要做一个判断，用到关键字instanceof，例如：

  ```java
  if(staff[1] instanceof Manager){
  	boss = (Manager) staff[1];
  }
  ```

- 实际上，强制类型转换通常不是一种好的做法，因为实现多态的动态绑定机制能够自动地找到之前的方法
- 只有在使用Manager中特有的方法时才需要进行强制类型转换
- 总结：
  - 只能在继承层次内进行强制类型转换
  - 在将超类强制转换成子类之前，应该使用instanceof进行检查

## 7.抽象类

- 需要用到的关键字abstract，例如：

  ```java
  public abstract class Person{
  	...
  	public abstract String getDesccription();
  }
  ```

  

- 抽象类中不一定有抽象方法，也可以有字段和具体的方法，但是抽象方法必须在抽象类中

- 扩展抽象类有两种选择：

  - 在子类中保留抽象类中的部分或所有抽象方法仍为定义，这样子类就必须是抽象类
  - 定义抽象类中的全部方法，子类就不是抽象类了

- 如果将一个类声明为abstract，就不能创建这个类的对象（抽象类不能实例化），但是可以创建一个具体子类对象

- 可以定义一个抽象类的`对象变量`，但是这样一个变量只能引用非抽象子类的对象

## 8.受保护访问

| 访问修饰符 | 同一个类 | 同包 | 不同包，子类 | 不同包，非子类 |
| ---------- | -------- | ---- | ------------ | -------------- |
| private    | √        |      |              |                |
| 默认       | √        | √    |              |                |
| protected  | √        | √    | √            |                |
| public     | √        | √    | √            | √              |
