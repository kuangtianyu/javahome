###  对象包装器与自动装箱

- 有时需要将基本类型转换为对象。所有的基本类型都有一个与之对应的类，这些类称为`包装器`

- 常见的包装器类：`Integer`、`Long`、`Float`、`Double`、`Short`、`Byte`、`Character`和`Boolean`

- 包装类是不变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时，包装器类还是final，因此不能派生它们的子类

- 数组列表的泛型是类，不能是基本类型，因此以下写法是错误的：

  ```java
  var list = new ArrayList<Int>;
  ```

  而因写成其包装器类：

  ```java
  var list = new ArrayList<Integer>;
  ```

  警告：由于每个值分别包装在对象中，所以`ArrayList`<Integer>的效率远远低于`int`[] 数组

- **自动装箱**：向`ArrayList`<Integer>添加`int`类型的元素：

  ```java
  list.add(3);
  ```

  将会自动地变换成：

  ```java
  list.add(Integer.ValueOf(3));
  ```

  这种变换称为`自动装箱`

- **自动拆箱**：当将一个`Integer`对象赋给一个`int`值时，将会自动地拆箱：

  ```java
  int n = list.get(i);
  ```

  自动的转换成：

  ```java
  int n = list.get(i).intValue();
  ```

- 自动地装箱和拆箱也适用于算术表达式。例如：可以将自增运算符应用于一个包装器引用：

  ```java
  Integer n =  3;
  n++;
  ```

  编译器将自动地插入一条对象拆箱的指令，然后进行自增计算，最后再将结果装箱

- 由于包装器引用可以为`null`，所以自动装箱有可能会抛出一个`NullPointerException`
- 如果在一个条件表达式中混合使用`Integer`  和 `Double`类型，`Integer`值就会拆箱，提升为`double`，在装箱为Double
- 装箱和拆箱是编译器要做的工作，而不是虚拟机。编译器生成类的字节码文件时会插入必要的方法调用，虚拟机只是执行这些字节码
- `java.lang.Integer`
  - `int` `intValue`()：将这个`Integer`对象的值作为一个`int`返回（覆盖`Number`类中的`intValue`方法）
  - `static String toString(int i)`：返回一个新的`String`对象，表示指定数值 `i` 的十进制表示
  - `static String toString (int i, int radix)`：返回数值`i`基于`radix`参数指定进制的表示
  - `static int parseInt(String s)`
  - `static int parseInt(String s, int radix)`：返回字符串`s`表示的整数，指定字符串必须表示一个十进制整数（第一种方法），或者采用`radix`参数指定的进制（第二种方法）
  - `static Integer valueOf(String s)`
  - `static Integer valueOf(String s, int radix)`：返回一个新的`Integer`对象，用字符串`s`表示的整数初始化。指定字符串必须表示一个十进制整数（第一种方法），或者采用`radix`参数指定的进制（第二种方法）
- `java.text.NumberFormat`
  - `Number parse(String s)`：返回数字值，假设给定的`String`表示一个数组
