## 反射

- 反射：能够分析类能力的程序
- 反射的作用：
  - 在运行时分析类的能力
  - 在运行时检查对象
  - 实现泛型数组操作代码
  - 利用Method对象，这个对象很像C++中的函数指针

### 1.`Class`类

- 得到Class对象的三个方法：

  - 调用`getClass()`方法：

    ```java
    var generator = new Random();
    Class cl = generator.getClass();
    ```

  - `Class.forName()`：

    ```java
    String className = "java.util.Random";
    Class cl = Class.forName(className);
    ```

  - `.class`:

    ```java
    Class cl = Random.class; //if you import java.util.*;
    ```

    注意：一个Class对象实际上表示的是一个类型，这可能是类，也可能不是类。例如：

    int不是类，但是 `int.class` 时一个Class类型的对象

- 虚拟机为每一个类型管理一个唯一的Class对象。因此可以使用==运算符实现两个类对象的比较。例如：

  ```java
  if(e.getClass() == Employee.class)...
  ```

  如果e是一个Employee实例，这个测试将通过。与条件`e instanceof Employee`不同，如果e是某个子类（如Manager）的实例，这个类将测试失败                  

- `java.lang.Class`
  
  - `static Class forName(String className)`：返回一个`Class`对象，表示名为`className`的类
  - `Constructor getConstructor(Class... parameterTypes)`：生成一个对象，描述有指定参数类型的构造器
- `java.lang.reflect.Constructor`
  
  - `Object newInstance(Object... params)`：将`params`传递到构造器，来构造这个构造器声明类的一个新实例
- `java.lang.Throwable`
  
  - `void printStackTrace()`：将`Throwable`对象和堆栈轨迹打印到标准错误流

### 2.声明异常入门

- 检查型异常：编译器将会检查你是否知道这个异常并做好准备来处理这个异常。

- 非检查型异常：编译器并不希望你为这些异常提供处理器，你应该集中精力避免这些错误的发生，而不要将精力花在编写异常处理器上。例如：

  越界错误或者访问null引用

- 处理检查异常的方法：

  - 抛出(throws)：

    ```java
    public static void doSomethingWithClass(String name) throws ReflectiveOperationException{
    	Class cl = Class.forName(name); //might throw exception
    	do something with cl
    }
    ```

    调用这个方法的任何方法也都需要一个throws声明。包括main方法。如果一个异常确实出现，main方法将终止并提供一个堆栈轨迹

  - try/catch：以后专门讲

### 3.利用反射分析类的能力

- 在`java.lang.reflect`包中有三个类`Field`、`Method`和`Constructor`分别用于描述类的字段、方法和构造器

- `getName`：用来返回字段、方法或构造器的名称

- `Field`类有一个`getType`方法，用来返回描述字段类型的一个对象，这个对象的类型同样是`Class`

- `Method`和`Constructor`类有报告此事类型的方法，`Method`类还有一个报告返回类型的方法

- `getModifiers`方法：它将返回一个整数，用不同的0/1位描述所使用的修饰符，如`public`和`static`

- 可以使用Modifier类中的`isPublic`、`isPrivate`、`isFinal`判断方法或构造器是`public`、`private`还是`final`

- `Class`类中的`getFields`、`getMethod`和`getConstructor`方法将分别返回这个类支持的`公共`字段、方法和构造器的数组，其中包括超类的公共成员

- Class类的`getDeclareFields`、`getDeclareMethods`和`getDeclaredConstructors`方法将分别返回类中声明的全部字、方法和构造器的数组，其中包括私有成员、包成员和受保护成员，但不包括超类的成员

- `java.lang.Class`

  - `Field[] getFields()`
  - `Field[] getDeclaredFields()`：`getFields`方法将返回一个包含`Field`对象的数组，这些对象对应这个类或其超类的公共字段。`getDeclaredField`方法也返回包含`Field`对象的数组，这些对象对应这个类的全部字段。如果类中没有字段，或者`Class`对象描述的是基本类型或数组类型，这些方法将返回一个长度为0的数组
  - `Method[] getMethods()`
  - `Method[] getDeclaredMethods()`：返回包含`Method`对象的数组：`getMethods`将返回所有的公共方法，包括从超类继承来的公共方法；`getDeclareMethods`返回这个类或接口的全部方法，但不包括由超类继承的方法
  - `Constructor[] getConstructors()`
  - `Constructor[] getDeclaredConstructors`：返回包含`Constructor`对象的数组，其中包含`Class`对象所表示的类的所有公共构造器（`getConstructors`）或全部构造器（`getDeclaredConstructors`）
  - String `getPackageName`()：得到包含这个类型的包的包名，如果这个类型是一个数组类型，则返回元素类型所属的包，或者如果这个类是一个基本类型，则返回`"java.lang"`

- `java.lang.reflect.Field`

  `java.lang.reflect.Method`

  `java.lang.reflect.Constructor`

  - `Class getDeclaringClass()`：返回一个`Class`对象，表示定义了这个构造器、方法或字段的类
  - `Class[] getExceptionTypes()`（在`Constructor`和`Method classes`类中）：返回一个`Class`对象数组，其中各个对象表示这个方法所抛出异常的类型
  - `int getModifiers()`：返回一个整数，描述这个构造器、方法或字段的修饰符。使用`Modifier`类中的方法类分析这个返回值
  - `String getName()`：返回一个表示构造器名、方法名或字段名的字符串
  - `Class[] getParameterTypes()`（在`Constructor`和`Method classes`类中）：返回一个`Class`对象数组，其中各个对象表示参数的类型
  - `Class getReturnType()`（在`Metho`类中）：返回一个用于表示返回类型的`Class`对象

- `java.lang.reflect.Modifier`

  - `static String toString(int modifiers)`：返回一个字符串，包含对应`modifiers`中位设置的修饰符

  - `static boolean isAbstract (int modifiers)`

  - `static boolean isFinal (int modifiers)`

  - `static boolean isInterface (int modifiers)`

  - `static boolean isNative (int modifiers)`

  - `static boolean isPrivate (int modifiers)`

  - `static boolean isProtected (int modifiers)`

  - `static boolean isPublic (int modifiers)`

  - `static boolean isStatic (int modifiers)`

  - `static boolean isStrict (int modifiers)`

  - `static boolean isSynchronized (int modifiers)`

  - `static boolean isVolatile (int modifiers)`

    这些方法经检测modifiers值中与方法名中修饰符对应的二进制位。

###  4.使用反射在运行时分析对象

- 利用反射机制可以查看在编译时还不知道的对象字段：使用`get`方法

  如果f是一个`Field`类型的对象（例如，通过`getDeclaredFields`得到的对象），`obj`是某个包含f字段的类的对象，`f.get(obj)`将返回一个对象，其值为`obj`的当前字段值

- 设置对象字段的值：`set`方法

  调用`f.set(obj,value)`将把对象`obj`的`f`表示字段设置为新值

- `get`方法和set方法查看和设置私有字段会抛出一个`IllegalAccessException`异常。只能对可以访问的字段使用`get`和`set`方法。Java安全机制允许查看一个对象有哪些字段，但是除非拥有访问权限，否则不允许读写那些字段的值

- 反射机制的默认行为受限于Java的访问控制，可以调用`Field`、`Method`或`Constructor`对象的`setAccessible`方法覆盖Java的访问控制：

  ```java
  f.setAccessible(true); //now OK to call f.get(harry)
  ```

  如果不允许访问，`setAccessible`调用会抛出一个异常。访问可以被模块系统或安全管理器拒绝

- 可用于任意类的通用`toString`方法：使用 `getDeclaredFileds`获得所有的数据字段，如果使用`setAccessible`便利方法将所有的字段设置为可访问的。对于每个字段，将获得名字和值。通过递归调用`toString`方法，将每个值转换为字符串

- `java.lang.reflectAccessibleObject`
  - `void setAccessible(boolean flag)`：设置或取消这个可访问标志，如果拒绝访问则抛出一个`IllegalAccessExcepion`异常
  - `void setAccessible(boolean flag)`
  - `boolean trySetAccessible()`：为这个可访问的对象设置可访问标志，如果拒绝访问则返回`false`
  - `boolean isAccessible()`：得到这个可访问对象的可访问标志值
  - `static void setAccessible(AccessibleObject[] array, boolean flag)`：这是一个便利方法，用于设置一个对象数组的可访问标志
- `java.lang.Class`
  - `Field getField(String name)`
  - `Field[] getFields()`：得到指定名的公共字段，或所有这些字段的一个数组
  - `Field getDeclaredField(String name)`
  - `Field[] getDeclaredFields()`：得到类中声明的指定名的字段，或者所有这些字段的一个数组
- `java.lang.reflect.Field`
  - `Object get(Object obj)`：返回`obj`对象中庸这个`Field`对象描述的字段的值
  - `void set(Object obj, Object newValue)`：将`Obj`对象中这个`Field`对象描述的字段设置为一个新值

### 5.使用反射编写泛型数组代码

- `java.lang.reflect`包中的`Array`类允许动态地创建数组。例如，`Array`类中的`copyOf`方法实现就使用了这个类。这个方法可以用于扩展一个已经填满的数组

  ```java
  var a = new Employee[100];
  ...
  //array is full
  a = Arrays.copyOf(a,2 * a.length);
  ```

- 利用`Array`类的静态方法`newInstance`，这个方法能够构造一个新数组。在调用这个方法时必须提供两个参数，一个是数组的元素类型，一个是数组的长度

  ```java
  Object newArray = Array.newInstance(componentType, newLength);
  ```

  - 可以通过调用`Array.getLength(a)`获得数组的长度。`Array`类的静态方法`getLength`方法会返回一个数组的长度。
  - 获取新数组的元素类型：
    - 首先获得a数组的类对象
    - 确认它是一个数组
    - 使用`Class`类的`getComponentType`方法（只为表示数组的类对象定义了这个方法）确定数组的正确类型

  - 注意：这个`CopyOf`方法可以用来扩展任意类型的数组，而不仅是对象数组。

    ```java
    int[] a = {1,2,3,4,5};
    a = (int[]) goodCopyOf(a,10);
    ```

    应该将`goodCopyOf`的参数声明为Object类型，而不要声明为对象型数组。整型数组类型 `int[]` 可以转换成`Object`，但不能转换成对象数组

    注意：`badCopyOf`的返回值进行强制类型转换将会抛出一个异常

- `java.lang.reflect.Array`
  - `static Object get(Object array, int index)`
  - `static xxx getXxx(Object array, int index)`：（`xxx`是`boolean、type、char、double、float、int、long、short`中的一种基本类型。）这些方法将返回存储在给定数组中给定索引位置上的值
  - `static void set(Object array, int index, Object newValue)`
  - `static setXxx(Object array, int index, xxx newValue)`：（`xxx`是`boolean、byte、char、double、float、int、long、short`中的一种基本类型）这些方法将一个新值存储到给定数组中的给定位置上
  - `static int getLength(Object array)`：返回给定数组的长度‘
  - `static Object newInstance(Class componentType, int length)`
  - `static Object newInstance(Class componentType, int[] lengths)：`返回一个有给定类型、给定大小的新数组

### 6.调用任意方法和构造器

- invoke方法的签名：

  ```java
  Object invoke(Object obj, Object... args)
  ```

  第一个参数是隐式参数，其余的对象提供了显示参数。对于静态方法，第一个参数可以省略，及可以将它设置为null。如果返回类是基本类型，invoke方法会返回其包装器类型 

- 调用任意的构造器。将构造器的参数类型提供给`Class.getConstructor`方法，并把参数值提供给`Constructor.newInstance`方法：

  ```java
  Class cl = Random.class;
  Constructor cons = cl.getConstructor(long.class);
  Object obj = cons.newInstance(42L);
  ```

- `java.lang.reflect.Method`
  - `public Object invoke(Object implicitParameter, Object[] explicitParameters)`：调用这个对象描述的方法，传入给定参数，并返回方法的返回值。对于静态方法，传入null作为隐式参数。使用包装器传递基本类型值。基本类型的返回值必须是未包装的
