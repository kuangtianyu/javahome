# Java集合框架

- Java 最初的版本只为最常用的数据结构提供了很少的一组类：Vector、Stack、Hashtable、BitSet与 Enumeration接口，其中的 Enumeration 接口提供了一种用于访问任意容器中个元素的抽象机制

## 一、集合接口与实现分离

- 与现代的数据结构类库的常见做法一样，Java集合类库也将接口与实现分离
- 队列接口指出可以在队列的尾部添加元素，在队列的头部删除元素，并且可以查找队列中元素的个数。但需要收集对象，并按照 ”先进先出“ 方式检索对象时就应该使用队列
- 队列通常有两种实现方式：一种是使用循环数组；另一种是使用链表
- 如果需要一个循环数组队列，可以使用 ArrayDeque 类。如果需要一个链表队列，就直接使用 LinkedList 类，这个类实现了 Queue 接口
- 循环数组要比链表更高效，因此多数人优先选择循环数组
- 循环数组是一个有界集合，即容量有限。如果程序中要收集的对数量没有上限，就最好使用链表来实现

## 二、Collection 接口

- 在 Java 类库中， 集合类的基本接口是 Collection 接口。这个接口有两个基本方法：

  ```java
  public interface Collection<E> {
  	boolean add(E element);
  	Iterator<E> iterator();
  }
  ```

  add 方法用于向集合中添加元素。如果添加元素确实改变了集合就返回 true；如果集合没有发生变化就会false。例如，如果试图向集（set）中添加一个对象，而这个对象在集中已经存在，这个add方法请求就没有实效，因为集中不允许有重复的对象

  iterator方法用于返回一个实效了 Iterator 接口的对象。可以使用这个迭代器对象一次访问集合中元素

## 三、迭代器

- Iterator 接口包含4个方法：

  ```java
  public interface Iterator<E> {
  	E next();
  	boolean hasNext();
  	void remove();
  	default void forEachRemaining(Consumer<? super E> action);
  }
  ```

  通过反复调用 next 方法，可以逐个访问集合中的每个元素。如果到达了集合的末尾，next 方法将抛出一个 NoSuchElementException 。因此，需要在调用 next 之前调用 hasNext 方法。如果迭代器对象还有多个可以访问的元素，这个方法就返回 true。如果想要查看集合中的所有元素， 就请求一个迭代器，当 hasNext 返回 true 时就反复地调用 next 方法：

  ```java
  Collection<String> c = ...;
  Iterator<String> iter = c.iterator();
  while (iter.hasNext()) {
  	String element = iter.next();
  	do something with element;
  }
  ```

- for each 循环：

  ```java
  for (String element : c) {
  	do something with element
  }
  ```

  编译器简单地将 ”for each“ 循环转换为带有迭代器的循环。

  “for each” 循环可以处理任何实现了Iterable接口的对象。Collection 接口扩展了 Iterable 接口。因此， 对于标准类库中的任何集合都可以使用 “for each” 循环

- 也可以不写循环，而是调用 forEachRemaining 方法并提供一个 lambda 表达式（它会处理一个元素）。将对迭代器的每一个元素调用这个 lambda 表达式，直到再没有元素为止：

  ```java
  iterator.forEachRemaining(element -> do something with element);
  ```

- 访问元素的顺序取决于集合类型。如果迭代处理一个 ArrayList， 迭代器将从索引 0 开始，没迭代一次，索引值加 1 。不过，如果访问 HashSet 中的元素，会按照一种基本上随机的顺序获得元素。虽然可以确保在迭代过程中能够遍历到集合中的所有元素，但是无法预知访问各个元素的顺序。这通常并不是什么问题，因为对于计算总和或统计匹配之类的计算，顺序并不重要。

- 查找一个元素的唯一方法是调用 next ，而在执行查找操作的同时，迭代器的位置会随之向前移动。因此可以认为 Java 迭代器位于两个元素之间。当调用 next 是，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用

- Iterator 接口的 remove 方法将会删除上次调用 next 方法时返回的元素。如果想要删除指定位置上的元素，仍然需要越过这个元素：

  ```java
  Iterator<String> it = c.iterator();
  it.next(); // skip over the first element
  it.remove(); // now remove it
  ```

  next 方法和 remove  方法之间存在依赖性。如果调用 remove 之前没有调用 next， 将是不合法的。否则会抛出 IllegalStateException 异常

- 如果想删除两个相邻的元素，不能直接这样调用：

  ```java
  it.remove();
  it.remove(); // ERROR
  ```

  实际上，必须先调用 next 越过将要删除的元素：

  ```java
  it.remove();
  it.next();
  it.remove(); // ERROR
  ```

## 四、泛型实用方法

- 由于 Collection 与 Iterator 都是泛型接口，这意味着你可以编写处理任何集合类型的实用方法。
- java.util.Collection<E>:
  - Iterator<E> iterator()：返回一个用于访问集合中各个元素的迭代器
  - int size()：返回当前储存在集合中的元素个数
  - boolean isEmpty()：如果集合中没有元素，返回 true
  - boolean contains(Object obj)：如果集合中包含了一个与 obj 相等的对象， 返回 true
  - boolean containsAll(Collection<?> other)：返回这个集合 other 集合中的所有元素，返回 true
  - boolean add(E element)：将一个元素添加到集合中。如果由于这个调用改变了集合，返回 true
  - boolean addAll(Collection<? extends E> other)：将 other 集合中的所有元素添加到这个集合。如果由于这个调用改变了集合，返回 true
  - boolean remove(Object obj)：从这个集合中删除等于 obj 的对象。如果有匹配的对象被删除，返回 true
  - boolean removeAll(Collection<?> other)：从这个集合中删除 other 集合中存在的所有元素。如果由于这个调用改变了集合，返回 true
  - default boolean removeIf(Predicate<? super E> filter)：从这个集合中删除 filter 返回true的所有元素。如果由于这个调用改变了集合，返回 true
  - void clear()：从这个集合中删除所有的元素
  - boolean retainAll(Collection<?> other)：从这个集合中删除所有与 other 集合中元素不同的元素。如果由于这个调用改变了集合，返回 true
  - Object[] toArray()：返回这个集合中的对象的数组
  - <T> T[] toArray(T[] arrayToFill)：返回这个集合中的对象的数组。如果 arrayToFill 足够大，就将集合中的元素填入这个数组中，剩余空间填补 null；否则，分配一个新数组，其成员类型与 arrayToFill 的成员类型相同，其长度等于集合的大小，并填充集合元素
- java.util.Iterator<E>:
  - boolean hasNext()：如果存在另一个可访问的元素，返回 true
  - E next()：返回将要访问的下一个对象。如果已经到达了集合的末尾，将抛出一个 NoSuchElementException
  - void remove()：删除上次访问的对象，这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后集合已经发生了变化，这个方法将抛出一个 IllegalStateException
  - default void forEachRemaining(Consumer<? super E> action)：访问元素，并传递到指定的动作，直到再没有更多元素，或者这个动作抛出一个异常。