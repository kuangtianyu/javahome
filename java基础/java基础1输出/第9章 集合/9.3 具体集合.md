具体集合

- Java 库中的具体集合：

  | 集合类型        | 描述                                         |
  | --------------- | -------------------------------------------- |
  | ArrayList       | 可以动态增长和缩减的一个索引序列             |
  | LinkedList      | 可以在任何位置高效插入和删除的一个有序序列   |
  | ArrayDeque      | 实现为循环数组的一个双端队列                 |
  | HashSet         | 没有重复元素的一个无序集合                   |
  | TreeSet         | 一个有序集                                   |
  | EnumSet         | 一个包含枚举类型值的集                       |
  | LinkedHashSet   | 一个可以记住元素插入次序的集                 |
  | PriorityQueue   | 有序高效删除最小元素的一个集合               |
  | HashMap         | 存储键/ 值关联的一个数据结构                 |
  | TreeMap         | 键有序的一个映射                             |
  | EnumMap         | 键属于枚举类型的一个映射                     |
  | LinkedHashMap   | 可以记住键 / 值添加次序的一个映射            |
  | WeakHashMap     | 值不会在别处使用时就可以被垃圾回收的一个映射 |
  | IdentityHashMap | 用 == 而不是用 equals 比较键的一个映射       |

## 一、链表

- 数组和数组列表都有一个重大的缺陷：从数组中间删除一个元素开销很大。原因：数组中位于被删除元素之后的所有元素都要向数组的前端移动。在数组中插入一个元素也是如此

- 数组是在连续的存储位置上存放对象引用，而`链表`则是将每个对象存放在单独的链接中。每一个链接还存放着序列中下一个链接的引用。在 Java 中，所有链表实际上都是`双向链接`——即每个链接还存放着其前驱的引用

- 从链表中间删除一个元素是一个很轻松的操作，只需要更新所删除元素周围的链接即可

- 链表是一个`有序集合`，每个对象的位置十分重要。LinkedList.add 方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。由于迭代器描述了集合中的位置，所有这种依赖于位置的add方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义

- set 方法用一个新元素调用 next 或 previous 方法返回的上一个元素：

  ```java
  ListIterator<String> iter = list.listIterator();
  String oldValue = iter.next(); // returns first element
  iter.set(newValue); // sets first element to newValue
  ```

  如果在某个迭代器修改集合时，另一个迭代器却在遍历这个集合，那么一定会出现混乱。例如：假设一个迭代器指向一个元素前面的位置，，而另一个迭代器刚刚删除了这个元素，现在前一个迭代器就是无效的，并且不能在使用。链表迭代器设计可以检测到这种修改。如果一个迭代器发现它的集合被另一个迭代器修改了，或是被该集合自身的某个方法修改了，就会抛出一个 ConcurrentModificationException 异常

- 可以根据需要为一个集合关联多个迭代器，前提是这些迭代器只能读取集合。或者，可以在关联一个能同时读写的迭代器

- 集合可以跟踪更改操作的次数。每个迭代器都会为它负责的更改操作维护一个单独的更改操作数。在每个迭代器方法的开始处，迭代器会检查它自己的更改操作数是否与集合的更改操作数相等。如果不一致，就抛出一个 Concurrent ModificationException 异常

-  链表不支持快速随机访问。如果要查看链表中的第 n 个元素，就必须从头开始，越过 n - 1 个元素。所有在按整数索引访问元素时，程序员通常不选用链表

- LinkedList 类还是提供了一个用来访问某个特定元素的 get 方法：

  ```java
  LinkedList<String> list = ...;
  String obj = list.get(n);
  ```

  这个方法的效率并不太高。绝不应该使用这个“虚假”的随机访问来遍历链表。下面代码效率极低：

  ```java
  for (int i = 0; i < list.size(); i++)
  	do something with list.get(i);
  ```

  每次查找一个元素都要从列表的头部重新开始搜索。LinkedList 对象根本没有缓存位置信息

  get 方法的小优化：如果索引大于等于 size() / 2, 就从列表尾端开始搜索元素

- 使用链表的唯一理由：尽可能地减少在列表中间插入或删除元素的开销
- 建议避免使用以整数索引表示链表中位置的所有方法。如果需要对集合进行随机访问，就使用数组或 ArrayList，而不要使用链表

## 二、数组列表

- List 接口用于描述一个有序集合，并且集合中每个元素的位置很重要
- 访问List接口元素的两种协议：一种是通过迭代器，另一种是通过 get 和 set 方法随机地访问每个元素。后者不适用于链表，但 get 和 set 方法对数组很有用

## 三、散列集

- 散列表可以用于快速查找对象，散列表（hash table）为每个对象计算一个整数，称为散列码（hash code）。散列码是由对象的实例字段得出的一个整数。更准确的说，有不同数据的对象将产生不同的散列码
- 如果 a.equals(b) 为 true，a 与 b 必须有相同的散列码
- 在 Java 中， 散列码用链表数组实现，每个列被称为`桶`。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引
- 散列冲突：遇到桶已经被填充的情况。这时需要将新对象与桶中的所有对象进行比较，查看这个对象是否存在。如果散列码合理地随机分布，桶的数目也足够大，需要比较的次数就会很少

## 四、树集

- 树集是一个有序集合。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，值将自动地按照排序后的顺序呈现

- 每次将一个元素添加到树中时，都会将其放置在正确的排序位置上。因此，迭代器总是以有序的顺序访问每个元素

- 将一个元素添加到树中要比添加到散列表中慢。但是，与检查数组或链表中的重复元素相比，使用树会快很多

- 树的排序顺序必须是全序。也就是说，任意两个元素都必须是可比的，并且只有在两个元素相等时结果才为0

- java.util.TreeSet<E>
  - TreeSet()

  - TreeSet(Comparator<? super E> comparator)

    构造一个空树集

  - TreeSet(Collection<? extends E> elements)

  - TreeSet(SortedSet<E> s) 

    构造一个树集，并增加一个集合或有序集中的所有元素（对于后一种情况，要使用相同的顺序

- java.util.SortedSet<E>

  - Comparator<? super E> comparator()

    返回用于对元素进行排序的比较器。如果元素用 Comparable 接口的 comparaTo 方法进行比较则返回 null

  - E first()

  - E last()

    返回有序集中的最小元素或最大元素

- java.util.NavigableSet<E> 

  - E higher(E value)

  - E lower(E value)

    返回大于 value 的最小元素或小于 value 的最大元素，如果没有这样的元素则返回 null

  - E pollFirst()

  - E pollLast()

    删除并返回这个集中的最大元素或最小元素，这个集为空时返回 null

  - Iterator<E> descendingIterator()

    返回一个按照递减顺序遍历集中元素的迭代器

## 五、队列与双端队列

- 队列允许你高效的在尾部添加元素，并在头部删除元素。`双端对象`（即 deuqu) 允许在头部和尾部都高效地添加或删除元素。不支持在队列中间添加元素

- java.util.Queue<E>

  - boolean add(E element)

  - boolean offer(E element)

    如果队列没有满，将给定的元素添加到这个队列的队尾并返回 true。如果队列已满，第一个方法将抛出一个 IllegalStateException，而第二个方法返回 false

  - E remove()

  - E poll()

    假设队列不为空，删除并返回这个队列对头的元素。如果队列是空，第一个方法抛出 NoSuchElementExcepiton，而第二个方法返回 null

  - E element()

  - E peek()

    如果对象不为空，返回这个队列对头的元素，但不删除。如果队列空，第一个方法将抛出一个 NoSuchElementException，而第二个方法返回 null

- java.util.Deque<E>

  - void addFirst(E element)

  - void addLast(E element)

  - boolean offerFirst(E element)

  - boolean offerLast(E element)

    将给定的对象添加到双端队列的队头或队尾。如果这个双端队列已满，前面两个方法将抛出一个 IllegalStateException，而后面两个方法返回 false

  - E removeFirst()

  - E removeLast()

  - E pollFirst()

  - E pollLast()

    如果这个双端队列不为空，删除并返回双端队列队头的元素。如果双端队列为空，前面两个方法将抛出一个 NoSuchElementException ，而后面两个方法返回 null

  - E getFirst()

  - E getLast()

  - E peekFirst()

  - E peekLast()

    如果两个双端队列非空，返回双端队列队头的元素，但不删除。如果双端队列为空，前面两个方法将抛出一个 NoSuchElementException，而后面两个方法返回 null

- java.util.ArrayDeque<E>

  - ArrayDeque()

  - ArrayDeque(int initialCapacity) 

    初始容量 16 或给定初始容量构造一个无限定双端队列

## 六、优先队列

- 优先队列中的元素可以按照任意的顺序插入，但会按照有序的顺序进行检索。也就是说，无论何时调用 remove 方法，总会获得当前优先队列中最小的元素。不过，优先队列并没有对所有元素进行排序。如果迭代处理这个元素，并不需要对它们进行排序。

- 优先队列使用了堆。堆是一个可以自组织的二叉树，其添加和删除操作可以让最小的元素移动到根，而不必花费时间对元素进行排序

- 优先队列的典型用法是任务调度

- java.util.PriorityQueue

  - PriorityQueue()

  - PriorityQueue(int initialCapacity)

    构造一个存放 Comparable 对象的优先队列

  - PriorityQueue(int initialCapacity, Comparator<? super E> c)

    构造一个优先队列，并使用指定的比较器对元素进行排序

