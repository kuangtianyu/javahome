# 捕获异常

### 7.2.1 捕获异常

- 如果发生了某个异常，但没有在任何地方捕获这个异常，程序就会终止，并在控制台上打印一个消息，其中包括这个异常的类型和一个堆栈轨迹

- 要想捕获一个异常，需要设置try/catch语句块：

  ```java
  try{
  	code
  	more code
  }catch(ExceptionType e){
  	handler for this type
  }
  ```

  如果try语句块中的任何代码抛出了catch子句中指定的一个异常类，那么：

  1. 程序将跳过try语句块的其余代码
  2. 程序将执行catch子句中的处理器代码

  如果try语句块中的代码没有抛出任何异常，那么程序将跳过catch子句

  如果方法中的任何代码抛出了catch子句中没有声明的一个异常类型，那么这个方法就会立即退出

- 如果调用了一个抛出检查型异常的方法，就必须处理这个异常，护着继续传递这个异常。哪种方法更好呢？一般经验是：要捕获哪些你知道如何处理的异常，而继续传递那些你不知道怎样处理的异常
- 如果想传播一个异常，，就必须在方法的首部添加一个throws说明符，提醒调用者这个方法可能会抛出异常
- 如果编写一个方法覆盖超类的方法，而这个超类方法没有抛出异常，你就必须捕获你的方法代码中出现的每一个检查型异常。不允许在子类的throws说明符中出现超类方法未列出的异常类

### 7.2.2 捕获多个异常

- 在一个try语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。要为每个异常类型使用一个单独的catch子句：

  ```java
  try{
  	code that migtht throw excepitons
  }catch(FileNotFoundException e){
  	emergency action for missing files
  }catch(UnknownHostException e){
  	emergency action for unknown hosts
  }catch(IOExcepiton e){
  	emergency action for all other I/O problems
  }
  ```

  异常对象可能包含有关异常性质的信息。要想获得这个对象的更多信息，可以尝试使用 e.getMessage() 得到详细的错误消息，或者使用e.getClass().getName()得到异常对象的实际类型

- 在Java 7 中，同一个catch子句中可以捕获多个异常类型。例如，假设对应缺少文件和未知主机异常的动作是一样的，就可以合并catch子句：

  ```java
  try{
  	code that migtht throw excepitons
  }catch(FileNotFoundException e){
  	emergency action for missing files and unknown hosts
  }catch(IOExcepiton e){
  	emergency action for all other I/O problems
  }
  ```

  只有当捕获的异常类型彼此之间不存在子类关系是才需要这个特性

- 捕获多个异常时，异常变量隐含为final变量

### 7.2.3 finally子句

-  代码抛出一个异常时，就会停止处理这个方法中剩余的代码，并退出这个方法。如果这个方法已经获得了只有它自己知道一些本地资源，而且这些资源必须清理，这个就会有问题。因此可以使用finally子句
- 不管是否有异常被捕获，finally子句中的代码都会执行
- try语句可以只有finally子句，而没有catch子句

### 7.2.5 try-with-Resources语句

- try-with-Resources语句的最简形式为：

  ```java
  try(Resource res = ...){
  	work with res
  }
  ```

  try 块退出时，会调用res.close()

- 只要需要关闭资源，就要尽可能使用try-with-resources语句
- try-with-resources语句自身也可以有catch子句，甚至还可以有一个finally子句。这些子句会在关闭资源之后执行

### 7.2.6 分析堆栈轨迹元素

- 堆栈轨迹是程序执行过程中某个特定点上所有挂起的方法调用的一个列表
- 当Java程序因为一个未不会的异常而终止时，就会显示堆栈轨迹
- 可以调用Throwable类的 printStackTrace方法访问堆栈轨迹的文本描述信息
- 一种更灵活的方法是使用StackWalker类，它会生成一个StackWalker.StackFrame实例流，其中每个实例分别描述一个栈帧