# 代理

### 1.何时使用代理

- 要想构造一个类的对象，这个类实现了一个或多个接口，但是在编译时你可能并不知道这些接口是什么。这个问题确实有些难度。要想构造一个具体的类，只需要使用newInstance方法或者使用反射找出构造器。但是，不能实例化接口，需要在运行的过程中定义一个新类。这时有些程序会生成代码，将这些代码放在一个文件中，调用编译器，然后再加载得到类文件。但是这样的速度比较慢。因此可以使用到代理。代理类可以在运行时创建全新的类。这样的代理类能够实现你指定的接口。代理类包含以下方法：
  - 指定接口所需的全部方法
  - Object类中的全部方法

### 2.创建代理对象

- 要想创建一个代理对象，需要使用Proxy类的`newProxyInstance`方法。这个方法有三个参数：
  - 一个类加载器。
  
  - 一个Class对象数组，每个元素对应需要实现的各个接口
  
  - 一个调用处理器
  
    ```java
    Object value = ...;
    //construct wrapper
    var handler = new TraceHandler(value);
    // construct proxy for one or more interfaces
    var interfaces = new Class[]{Comparable.class};
    Object proxy = Proxy.newProxyInstance(Class.getSystemClassLoader(), new Class[]{Comparable.class}, handler)
    ```
- 使用代理的目的：
  - 将方法调用路由到远程服务器
  - 在运行的程序中将用户界面事件与动作关联起来
  - 为了调试，跟踪方法调用

### 3.代理的特性

- 代理类是在查询运行过程中动态创建的。一旦被创建，它们就变成了常规类，与虚拟机中的任何其他类没有什么区别

- 所有的代理类都扩展Proxy类。一个代理类只有一个实例字段——即调用处理器，它在Proxy超类中定义。完成代理对象任务所需的任何额外的数据都必须储存在调用处理器中。

- 所有的代理类都要覆盖 Object 类的 toString、 equals和hashCode方法。如同所有的代理方法一样，这些方法只是在调用处理器上调用invoke。Object类中的其他方法（如clone和getClass）没有重新定义

- 没有定义代理类的名字，Oracle虚拟机中的Proxy类将生成一个以字符串 $Proxy 开头的类名。

- 对于一个特定的类加载器和预设的一组接口来说，只能有一个代理类。也就是说，如果使用同一个类加载器和接口数组调用两次newProxyInstance方法，将得到一个类的两个对象。也可以利用getProxyClass方法获得这个类：

  ```
  Class proxyClass = Proxy.getProxyClass(null, interfaces);
  ```

- 代理类总是public 和 final。 如果代理类实现的所有接口都是public，这个代理类就不属于任何特定的包；否则，所有非公共的接口都必须属于同一个包，同时，代理类也属于这个包
- 可以通过调用Proxy类的isProxyClass方法检测一个特定的Class对象是否表示一个代理类
- java.lang.reflect.InvocationHandler
  
- Object invoke(Object proxy, Method method, Object[] args)：定义这个方法包含一个动作，你希望只要在代理对象上调用一个方法就完成这个动作
  
- java.lang.reflect.Proxy
  - static Class<?> getProxyClass(ClassLoader loader, Class<?> ... interfaces)：返回实现指定接口的代理类
  - static Object newProxyIntance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler handler)：构造实现指定接口的代理类的一个新实例。所有方法都调用给定处理器对象的invoke方法
  - static boolean isProxyClass(Class<?> cl)：如果 cl 是一个代理类则返回true