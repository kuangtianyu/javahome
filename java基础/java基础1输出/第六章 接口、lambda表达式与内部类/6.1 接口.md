## 接口

#### 1.接口的概念

- 接口：在Java中，接口不是类，而是对希望符合这个接口的类的一组需求

- Comparable接口的代码：

  ```java
  public interface Comparable{
  	int compareTo(Object other);
  }
  ```

  关键字：interface

  说明：接口中的所有方法都自动是public方法。因此，在接口中声明方法时，不必提供关键字public.

- 接口中可以有多个方法，还可以在接口中定义常量，但是接口中绝对不会有实例字段。在`Java8`之前，接口中绝对不会实现方法，即接口没有实例

- 实现接口：

  - 将类声明为实现给定的接口：需要用到关键字 implements

  - 对接口中的所有方法提供定义

    ```java
    class Employee implements Comparable
    ```

- `java.lang.Comparable<T>`
  - `int compareTo(T other)`：用这个方法与`other`进行比较。如果这个对象小于`other`则返回一个负整数；如果相等则返回0；否则返回一个正整数
- `java.util.Arrays`
  - `static void sort(Object[] a)`：对数组`a`中的元素进行排序。要求数组中的元素必须属于实现了`Comparable`接口的类，并且元素之间必须是可比较的
- `java.lang.Integer`
  - `static int compare(int x, int y)`：如果 `x<y` 返回一个负整数；如果`x`和`y`相等，则返回0；否则返回一个正整数
- `java.lang.Double`
  - `static int compare(double x, double y)`：如果 `x<y` 返回一个负整数；如果`x`和`y`相等则返回0；否则返回一个正整数

#### 2.接口的属性

- 接口不是类。具体来说，不能使用`new`运算符实例化一个接口：

  ```java
  x = new Comparable(...); //ERROR
  ```

- 尽管不能构造接口的对象，却能声明接口的变量：

  ```java
  Comparable x; //OK
  ```

  接口变量必须引用实现了这个接口的类对象：

  ```java
  x = new Employee(...); //OK provided Employee implements Comparable
  ```

- 可以使用`instanceof`检查一个对象是否属于某个特定类一样，也可以使用`instanceof`检查一个对象是否实现了某个特定的接口：

  ```java
  if ( anObject instanceof Comparable){...}
  ```

- 与建立类的继承层次一样，也可以使用扩展接口。这里允许有多条接口链，从通用性较高的接口扩展到专用性较高的接口。例如，假设有一个名为`Moveable`的接口：

  ```java
  public interface Moveable{
  	void move(double x, double y);
  }
  ```

  然后，可以假设一个名为`Powered`的接口扩展了以上`Moveable`接口：

  ```java
  public interface Powered extends Moveable{
  	double milesPerGallon();
  }
  ```

- 虽然在接口中不能包含实例字段，但是可以包含常量。例如：

  ```java
  public interface Powered extends Moveable{
  	double milesPer'Gallon();
  	double SPEED_LIMIT = 77; //a public static final constant
  }
  ```

- 与接口中的方法都自动被设置为`public` 一样，接口中的字段总是`public static final。`

- 尽管每个类只能有一个超类，但却可以实现多个接口。例如：

  ```java
  class Employee implements Cloneable, Comparable
  ```

#### 3.接口与抽象类

- 每个类只能扩展一个抽象类。Java的设计者选择了不支持多重继承，主要原因是多重继承的复杂性和低效性
- 每个类可以实现多个接口

#### 4.静态和私有方法

- 在`Java8`中，允许在接口中增加静态方法
- 在`java9`中，接口中的方法可以是`private`。`private`方法可以是静态方法或实例方法。由于私有方法只能在接口本身的方法中使用，所有它们的用法很有限，只能作为接口中其他方法的辅助

#### 5.默认方法

- 可以为接口方法提供一个默认实现。必须使用default修饰符标记这样一个方法

  ```java
  public interface Comparable<T>{
  	// by default, all elements are the same
  	default int compareTo(T other) {
  		return 0;
  	}
  }
  ```

- 当然，这并没有太大用处，因为Comparable的每一个具体实现都会覆盖这个方法。不过有些情况下，默认方法可能很有用

#### 6.解决默认方法冲突

- 问题：如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义同样的方法，会发生什么情况？

- 解答：

  - 超类优先。如果超类提供了一个具体方法，同名且有相同参数类型的默认方法会被忽略

  - 接口冲突。如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突

    ```java
    interface Person{
    	default String getName(){
    		return "";
    	}
    }
    
    interface Named{
    	default String getName(){
    		return getClass.getName() + "_" + hashCode();
    	}
    }
    ```

    问题：如果有一个类同时实现了这个两个接口会怎么样呢？

    ```java
    class Student implements Person, Named{...}
    ```

    解决：类会继承`Perosn`和Named接口提供的两个不一致的`getName`方法。并不是从中选择一个，`Java`编译器会报告已错误，让程序员类解决这个二义性问题。只需要在`Student`类中提供一个`getName`方法即可。在这个方法中，可以选择两个冲突方法中的一个，如下所示：

    ```java
    class Student implements Person, Named{
    	public String getName(){
    		return Perosn.super.getName();
    	}
    }
    ```

    问题：Person是一个类，Student定义为：

    ```java
    class Student extends Person implements Named{...}
    ```

    解决：在这种情况下，只会考虑超类方法，接口中的所有默认方法都会被忽略（类优先规则） 

#### 7.对象克隆

- 默认的克隆（浅克隆）：使用赋值语句实现克隆：

  ```java
  var original = new Employee("John Public",50000);
  Employee copy = original;
  copy.raiseSalary(10);//oops--also changed original
  ```

  - 原变量和副变量都是同一个对象的引用，任何一个变量改变都会影响另一个变量。如果原对象和浅克隆对象共享的子对象是`不可变的`，那么这种共享就是安全的。如果子对象属于一个不可变的类，如String， 就是它这种情况。或者在对象的生命周期中，子对象一直包含不变的常量，没有更改器方法会改变它，也没有方法会生成它的引用，这种情况下同样是安全的。

- 深克隆：使用Cloneable接口中的方法：`clone`：

  ```java
  Employee copy = original.clone();
  copy.raiseSalary(10); //OK--original unchanged
  ```

  - `copy`是一个新对象，它的初始状态与original相同，但是之后它们各自会有自己不同的状态，这种情况下就要使用`clone`方法
  - `clone`方法是`Object`的一个protected方法，这个说明你的代码不能直接调用这个方法。只有`Employee`类可以克隆`Employee`对象
  - 应对的是子对象是`可变的`，因此可以同时克隆所有的子对象

- `Cloneable`接口的出现与接口的正常使用并没有关系，它没有指定`clone`方法，这个方法是从`Object`类继承的。这个接口只是作为一个标记，指示类设计者克隆的过程。如果一个对象请求克隆，但是没有实现这个接口，就会生成一个检查型异常。

- 标记接口：也称为记号接口，不包含任何方法；它唯一的作用就是允许在类型查询中使用`instanceof`

  ```java
  if(obj instanceof Cloneable)...
  ```

- 如果在一个对象上调用`clone`，但这个对象的类并没有实现`Cloneable`接口，`Object`类的`clone`方法就会抛出一个`CloneNotSupportedException`异常













