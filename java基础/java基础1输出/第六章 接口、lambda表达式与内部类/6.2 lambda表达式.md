# lambda 表达式

### 1.`lambda`表达式的语法

- `lambda`表达式形式：参数，箭头(->)以及一个表达式。如果代码要完成的计算无法放在一个表达式中，就可以向写方法一样，把这些代码放在{}中，并包含显式的`return`语句。例如：

  ```java
  (String first, String second) -> {
  	if(first.length() < second.length()) return -1;
  	else if( first.length() > second.length()) return 1;
  	else return 0;
  }
  ```

- 即使`lambda`表达式没有参数，仍然要提供空括号，就像无参数方法一样：

  ```java
  () -> {for (int i = 100; i >= 0; i--)System.out.println(i)}
  ```

- 如果可以推导出一个`lambda`表达式的参数类型，则可以忽略其类型。例如：

  ```java
  Comparator<String> comp
  	= (first, second) //same as (String first, String second)
  		-> first.length() - second.length();
  ```

  在这里，编译器可以推导出`first`和`second`必然是字符串，因为这个`lambda`表达式将赋给一个字符串比较器。

- 如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号：

  ```java
  ActionListener listener = event ->
  	System.out.println("The time is "
  		+ Instant.ofEpochMilli(event.getWhen()));
  		// instead of (event) -> ... or (ActionEvent event ) -> ...
  ```

- 无需指定`lambda`表达式的返回类型。`lambda`表达式的返回类型总是由上文推导得出。例如：

  ```java
  (String first, String second) -> first.length() - second.length()
  ```

  可以在需要`int`类型结果的上下文中使用

- 如果一个`lambda`表达式只在某些分支返回一个值，而另外一些分支不返回值，这是不合法的。例如：

  ```java
  (int x) -> {if(x >= 0) return 1;} //不合法
  ```

### 2.函数式接口

- 函数式接口：只有一个抽象方法的接口

-  实际上，在Java中，对lambda表达式所能做的只是转换为函数式接口。

- 一个有用的函数式接口：Supplier<T>：

  ```java
  public interface Supplier<T> {
  	T get();
  }
  ```

  供应者没有参数，调用时会生成一个T类型的值，供应者用于实现`懒计算`

### 3.方法引用

- 有时，`lambda`表达式涉及一个方法。假如，假设希望只要出现一个定时器事件就打印这个事件对象，你可以如下调用：

  ```java
  var timer = new Timer(1000, event -> System.out.println(event));
  ```

  但是，如果直接把`println`方法传递到`Timer`构造器就更好了，如下：

  ```java
  var timer = new Timer(1000, System.out::println);
  ```

  表达式`System.out::println`是一个`方法引用`，它指示编译器生成一个函数式接口的实例，覆盖这个接口的抽象方法来调用给定的方法

- 类似于lambda表达式，方法引用也不是一个对象。不过，为一个类型为函数式接口的变量赋值时会生成一个对象
- 要用 :: 运算符分隔方法名与对象或类名。主要有3种情况：
  - object::instanceMethod
  - Class::instanceMethod
  - Class::staticMethod