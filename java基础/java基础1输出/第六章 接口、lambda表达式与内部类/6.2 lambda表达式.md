# lambda 表达式

### 1.`lambda`表达式的语法

- `lambda`表达式形式：参数，箭头(->)以及一个表达式。如果代码要完成的计算无法放在一个表达式中，就可以向写方法一样，把这些代码放在{}中，并包含显式的`return`语句。例如：

  ```java
  (String first, String second) -> {
  	if(first.length() < second.length()) return -1;
  	else if( first.length() > second.length()) return 1;
  	else return 0;
  }
  ```

- 即使`lambda`表达式没有参数，仍然要提供空括号，就像无参数方法一样：

  ```java
  () -> {for (int i = 100; i >= 0; i--)System.out.println(i)}
  ```

- 如果可以推导出一个`lambda`表达式的参数类型，则可以忽略其类型。例如：

  ```java
  Comparator<String> comp
  	= (first, second) //same as (String first, String second)
  		-> first.length() - second.length();
  ```

  在这里，编译器可以推导出`first`和`second`必然是字符串，因为这个`lambda`表达式将赋给一个字符串比较器。

- 如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号：

  ```java
  ActionListener listener = event ->
  	System.out.println("The time is "
  		+ Instant.ofEpochMilli(event.getWhen()));
  		// instead of (event) -> ... or (ActionEvent event ) -> ...
  ```

- 无需指定`lambda`表达式的返回类型。`lambda`表达式的返回类型总是由上文推导得出。例如：

  ```java
  (String first, String second) -> first.length() - second.length()
  ```

  可以在需要`int`类型结果的上下文中使用

- 如果一个`lambda`表达式只在某些分支返回一个值，而另外一些分支不返回值，这是不合法的。例如：

  ```java
  (int x) -> {if(x >= 0) return 1;} //不合法
  ```

### 2.函数式接口

- 函数式接口：只有一个抽象方法的接口

-  实际上，在Java中，对lambda表达式所能做的只是转换为函数式接口。

- 一个有用的函数式接口：Supplier<T>：

  ```java
  public interface Supplier<T> {
  	T get();
  }
  ```

  供应者没有参数，调用时会生成一个T类型的值，供应者用于实现`懒计算`

### 3.方法引用

- 有时，`lambda`表达式涉及一个方法。假如，假设希望只要出现一个定时器事件就打印这个事件对象，你可以如下调用：

  ```java
  var timer = new Timer(1000, event -> System.out.println(event));
  ```

  但是，如果直接把`println`方法传递到`Timer`构造器就更好了，如下：

  ```java
  var timer = new Timer(1000, System.out::println);
  ```

  表达式`System.out::println`是一个`方法引用`，它指示编译器生成一个函数式接口的实例，覆盖这个接口的抽象方法来调用给定的方法

- 类似于lambda表达式，方法引用也不是一个对象。不过，为一个类型为函数式接口的变量赋值时会生成一个对象
- 要用 :: 运算符分隔方法名与对象或类名。主要有3种情况：
  - `object::instanceMethod`：方法引用等价于向方法传递参数的lambda表达式。对于`System.out::println`，对象是`System.out`，所以方法表达式等价于`x -> System.out.println(x)`。

  - `Class::instanceMethod`：第一个参数会成为方法的隐式参数。例如，`String::compareToIgnoreCase`等同于（`x，y）->.compareToIgnoreCase(y)`。

  - `Class::staticMethod`：所以的参数都传递到静态方法：`Math::pow`等价于（`x，y）->Math.pow(x, y)`。

    | 方法引用            | 等价的lambda表达式             | 说明                                                         |
    | ------------------- | ------------------------------ | ------------------------------------------------------------ |
    | `separator::equals` | `x->separator.equals(x)`       | 这是包含一个对象和一个实例方法的方法表达式。lambda参数作为整个方法的显示参数传入 |
    | `String::trim`      | `x -> x.trim()`                | 这是包含一个类和一个实例方法的方法表达式。lambda表达式会成为隐式参数 |
    | `String::concat`    | `(x,y) -> x.concat(y)`         | 同样，这里有一个实例方法，不过这次有一个显示参数。与前面一样，第一个lambda参数会成为隐式参数，其余的参数会传递到方法 |
    | `Integer::valueOf`  | `x -> Integer::valueOf(x)`     | 这是包含一个静态方法的方法表达式。lambda参数会传递到这个静态方法 |
    | `Integer::sum`      | `(x, y) -> Integer::sum(x, y)` | 这是另一个静态方法，不过这一次有两个参数。两个lambda参数都传递到这个静态方法。`Integer.sum`方法专门创建为作为一个方法引用。对于lambda表达式，可以只写作`(x, y) -> x + y` |
    | `Integer::new`      | `x -> new Integer(x)`          | 这是一个构造器引用，lambda参数传递到这个构造器               |
    | `Integer[] :: new`  | `n -> new Integer[n]`          | 这是一个数组构造器引用，lambda参数是数组长度                 |

    注意，只有当lambda表达式的体只调用一个方法而不做其他操作时，才能把lambda表达式重写为方法引用。考虑以下lambda表达式：

    ```java
    s -> s.length() == 0
    ```

    这里有一个方法调用。但是还有一个比较，所以这里不能使用方法引用。

- 可以在方法引用中使用this参数。例如，`this:equals` 等同于 `x -> this.equals(x)`。
- 可以在方法引用中使用super参数。例如，`super::instanceMethod`

### 4.构造器引用

- 构造器引用与方法引用很类似，只不过方法名为new。例如，Person::new 是Person构造器的一个引用

- 用数组类型建立构造器引用。例如，int[]::new 是一个构造器引用，它有一个参数：即数组的长度。这等价于lambda表达式 x-> new int[x]。

### 5.变量的作用域

- lambda表达式分为三个部分：

  - 一个代码块
  - 参数
  - 自由变量的值，这是指非参数而且不在代码中定义的变量

- lambda表达式可以捕获外围作用域中变量的值。但是有一个限制。在lambda表达式中，只能引用值不会改变的变量。例如，下面的做法是不合理的：

  ```java
  public static void countDown(int start, int delay){
  	ActionListener listener = event -> {
  		start--; //ERROR:Can't mutate captured variable
  		System.out.println(start);
  	};
      new Temer(delay, listener).start();
  }
  ```

  这个限制是由原因的。如果在lambda表达式中更改变量，并发执行多个动作时就会不安全

- 如果在lambda表达式中引用一个变量，而这个变量可能在外部改变，这也是不合法的。例如：

  ```java
  public static void repeat(String text, int count){
  	for(int i = 1; i <= count; i++){
  		ActionListener listener = event -> {
  			System.out.println(i + ": " + text);
  			//ERROR：Cannot refer to changing i 
  		}
  	}
  }
  ```

- 这里有一个规则：lambda表达式中捕获的变量必须实际上是`事实最终变量`。事实最终变量是指，这个变量初始化之后就不会再为它赋新值

- lambda表达式的体与`嵌套块有相同的作用域`。这里同样适用命名冲突和遮蔽的有关规则。在lambda表达式中声明与一个局部变量同名的参数或局部变量是不合法的。

  ```java
  Path first = Path.of("/usr/bin");
  Comparatior<String> comp = (first, second) -> first.length() - second.length();
  // ERROR: Variable first already defined
  ```

  在这个方法中，不能有两个同名的局部变量，因此，lambda表达式中同样也不能有同名的局部变量。

- 在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数

  ```java
  public class Application{
  	public void init(){
  		AcrtionListener listener = event -> {
  			system.out.println(this.toString());
  		}
  	}
  }
  ```

  表达式`this.toString()` 会调用`Application` 对象的`toString` 方法，而不是`ActionListener`实例的方法。

### 6.处理lambda表达式

- 使用lambda表达式的重点是`延迟执行`，希望以后再执行代码的原因：

  - 在一个单独的线程中运行代码；
  - 多次运行代码
  - 在算法的适当位置运行代码（例如，排序中的比较操作）；
  - 发生某种情况时执行代码（如，点击了一个按钮，数据到达，等等）；
  - 只在必要时才运行代码

- 常用的函数式接口

  | 函数式接口          | 参数类型 | 返回类型 | 抽象方法名 | 描述                         | 其他方法                   |
  | ------------------- | -------- | -------- | ---------- | ---------------------------- | -------------------------- |
  | Runnable            | 无       | void     | run        | 作为无参数或返回值的动作运行 |                            |
  | Supplier<T>         | 无       | T        | get        | 提供一个T类型的值            |                            |
  | Consumer<T>         | T        | void     | accept     | 处理一个T类型的值            | andThen                    |
  | BiConsumer<T, U>    | T, U     | void     | accept     | 处理T和U类型的值             | andThen                    |
  | Function<T, R>      | T        | R        | apply      | 有一个T类型参数的函数        | compose, andThen, identity |
  | BiFunction<T, U, R> | T, U     | R        | apply      | 有T和U类型参数的函数         | andThen                    |
  | UnaryOperator<T>    | T        | T        | apply      | 类型T上的一元操作符          | compose, andThen, identity |
  | BinaryOperator<T>   | T, T     | T        | apply      | 类型T上的二元操作符          | andThen, maxBy, minBy      |
  | Predicate<T>        | T        | boolean  | test       | 布尔值函数                   | and, or, negate, isEqual   |
  | BiPredicate<T, U>   | T, U     | boolean  | test       | 有两个参数的布尔值函数       | and, or, negate            |